{"version":3,"sources":["usePullRefreshScrollView.ts"],"names":["useEffect","useMemo","runOnJS","useAnimatedRef","useSharedValue","useAnimatedScrollHandler","withTiming","Gesture","usePullRefreshScrollView","refreshing","callback","power","bounceOnPull","loaderHeight","scrollAnimatedValue","viewProps","ref","scrollY","scrollHeight","startY","dragging","onScrollProxy","onScroll","panGesture","Pan","enabled","simultaneousWithExternalGesture","onUpdate","e","scroll","value","posY","translationY","newPosY","onEnd","gestures","Simultaneous","scrollHandler","event","contentOffset","y"],"mappings":"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","sourcesContent":["import { useEffect, useMemo } from 'react';\nimport Animated, {\n  runOnJS,\n  useAnimatedRef,\n  useSharedValue,\n  useAnimatedScrollHandler,\n  withTiming,\n} from 'react-native-reanimated';\nimport { Gesture } from 'react-native-gesture-handler';\n\ninterface BasicScrollProps {\n  onScroll?: (args: any) => void;\n}\n\ninterface Props extends BasicScrollProps {\n  refreshing: boolean;\n  callback(): void;\n  power: number;\n  bounceOnPull: boolean;\n  loaderHeight: number;\n  scrollAnimatedValue?: Animated.SharedValue<number>;\n}\n\nfunction usePullRefreshScrollView({\n  refreshing,\n  callback,\n  power,\n  bounceOnPull,\n  loaderHeight,\n  scrollAnimatedValue,\n  ...viewProps\n}: Props) {\n  const ref = useAnimatedRef<any>();\n  const scrollY = useSharedValue(0);\n  const scrollHeight = useSharedValue(0);\n  const startY = useSharedValue(0);\n  const dragging = useSharedValue(false);\n\n  const onScrollProxy = useMemo(() => viewProps.onScroll, [viewProps.onScroll]);\n\n  const panGesture = Gesture.Pan()\n    .enabled(!refreshing)\n    .simultaneousWithExternalGesture(ref)\n    .onUpdate((e) => {\n      const scroll = scrollY.value;\n      let posY = e.translationY - startY.value;\n\n      // is on top and is intention to pull\n      if (scroll <= 0 && posY > 0) {\n        if (!dragging.value) {\n          startY.value = e.translationY;\n        }\n\n        dragging.value = true;\n      }\n\n      // is not on top and is intention scroll\n      if (scroll >= 0 && posY < 0) {\n        if (dragging.value) {\n          startY.value = e.translationY;\n        }\n\n        dragging.value = false;\n      }\n\n      posY = e.translationY - startY.value;\n\n      if (dragging.value) {\n        let newPosY = posY * power;\n\n        // when bounceOnPull is disabled we limit the loaderHeight based on the prop\n        if (!bounceOnPull && newPosY >= loaderHeight) {\n          scrollHeight.value = loaderHeight;\n\n          return;\n        }\n\n        // avoid going negative values since we want to go positive only\n        scrollHeight.value = newPosY < 0 ? 0 : newPosY;\n      } else {\n        scrollHeight.value = withTiming(0);\n      }\n    })\n    .onEnd(() => {\n      if (scrollHeight.value >= loaderHeight * 0.75) {\n        runOnJS(callback)();\n      } else {\n        scrollHeight.value = withTiming(0);\n      }\n\n      startY.value = 0;\n      dragging.value = false;\n    });\n\n  const gestures = Gesture.Simultaneous(panGesture);\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      'worklet';\n      if (scrollAnimatedValue) {\n        scrollAnimatedValue.value = event.contentOffset.y;\n      }\n\n      onScrollProxy && onScrollProxy(event);\n      scrollY.value = event.contentOffset.y;\n    },\n  });\n\n  // effect for controlled loading state\n  useEffect(() => {\n    if (refreshing) {\n      scrollHeight.value = withTiming(loaderHeight);\n\n      return;\n    }\n\n    scrollHeight.value = withTiming(0);\n  }, [refreshing, loaderHeight, scrollHeight]);\n\n  return { ref, gestures, scrollHandler, scrollHeight, dragging };\n}\n\nexport default usePullRefreshScrollView;\n"]}